<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>决策树基础</title>
      <link href="/2022/10/12/%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/10/12/%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树大家应该都见过，直观一点就长下面这样，由根，叶，节点等等组成。</p><p><img src="https://img-blog.csdnimg.cn/20200521060617462.png"  width="50%"></p><p>其实一个决策树就是对特征值空间进行了划分。假如使用x1和x2特征进行分类，使用分割值$\theta_1$到$\theta_4$进行分割，实际上就是把空间分成了ABCDE，如左图所示。</p><p><img src="https://img-blog.csdnimg.cn/20200521061022685.png"  width="80%"></p><p>构建决策树的关键其实也就是在寻找特征值和分割阈值，即何时选择x1进行决策，以及$\theta$值的确认。</p><h1 id="决策树构建"><a href="#决策树构建" class="headerlink" title="决策树构建"></a>决策树构建</h1><p>构建决策树时候需要尽可能使得构建出的树越小越好，首先引入熵和信息增益的概念。</p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>熵这个概念应该最早是学化学的时候接触到的，用来表示目标的混乱程度。<br>用公式表示就是：</p><script type="math/tex; mode=display">H[s]=-\sum{p\log_2p}$$比如在伯努利分布中,概率分布和为1，即$P_{+}+P_{-}=1$如果$P_{+}=1$，则$P_{-}=0$,此时的熵为：$$H[s]=-P_{-}\log_2P_{-}-P_{+}\log_2P_{+}=-0-0=0</script><p>熵为0代表着结果是确定的。<br>假设$P_{+}=0.5$，则$P_{-}=0.5$,此时的熵为：</p><script type="math/tex; mode=display">H[s]=-P_{-}\log_2P_{-}-P_{+}\log_2P_{+}=1</script><p>熵最大，完全不确定x为正还是负。</p><p>构建决策树的时候也可以用基尼系数或者方差来代替熵。<br>对于特征的一组类别，计算熵的时候需要考虑权重。假设特征A有k个类别，每个类别的概率是$\frac{S_k}{S}$，则对于样本集合A来说熵为：</p><script type="math/tex; mode=display">H[A]=-\sum_{k=1}^{k}\frac{S_k}{S}\log_2\frac{S_k}{S}</script><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>假设结果Y受到ABC三种特征的影响，则我们可以求出ABC三种因素的熵值</p><script type="math/tex; mode=display">H[A],H[B],H[C]$$定义结果Y从A中获得的信息量（info gain）为$H[Y]-H[A]$，信息增益越大也就代表着混乱程度下降越快。所以想要构建最小棵的决策树，我们就需要遵循熵最快下降原则，选取增益最大的特征作为第一个判断原则，这样逐渐的构建起决策树。## 举个例子下图为打球与否和天气情况的关系图，其中天气情况缩写如下，每个特征都对应着不同的程度：Outlook: S(unny), O(vercast), R(ainy)Temperature: H(ot), M(edium), C(ool)Humidity: H(igh), N(ormal), L(ow)Wind: S(trong), W(eak)<img src="https://img-blog.csdnimg.cn/20200521063918770.png"  width="45%">所以按照刚刚讲述的步骤，首先计算打不打球的熵：$$play = 9/14$$$$not = 5/14$$$$H(Play?) = −(9/14) /log_2(9/14)−(5/14) /log_2(5/14)=0.94</script><p>接着计算每个天气特征的熵，这里展示了一下outlook的计算熵过程：</p><p><img src="https://img-blog.csdnimg.cn/20200521064645645.png"  width="50%"></p><p>Outlook: 0.246<br>Humidity: 0.151<br>Wind: 0.048<br>Temperature: 0.029<br>当计算完所有的天气特征熵并得到信息增益之后，就可以由大到小构建决策树了。<br>最终构建出的决策树如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200521065045762.png" width="70%"></p><h2 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h2><p>对于某些特征来说，自身的熵很小可能是因为自身发生的概率很小，这样会导致它的信息增益很大，影响决策树的构建，所以可以引入信息增益率来解决这个事情。<br>用信息增益除以本身的因素熵。</p><p>$$$$</p><h1 id="评价函数"><a href="#评价函数" class="headerlink" title="评价函数"></a>评价函数</h1><p>评价函数越小越好</p><h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><p>有些决策树可以实现完全的分类，但是树非常高，不怎么实用。</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><p>构建过程中提前停止，通常可以规定树高或者其他约束</p><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>通过改造评价函数</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大似然以及奥卡姆剃刀</title>
      <link href="/2022/10/12/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BB%A5%E5%8F%8A%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80/"/>
      <url>/2022/10/12/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BB%A5%E5%8F%8A%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80/</url>
      
        <content type="html"><![CDATA[<h1 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h1><p>已知一组数据x和结果y，知道或估计到它们的分布模式，假如是伯努利分布，最大似然估计就是可以求出一个参数使得x和y的拟合程度最好。<br>即在参数为的时候，x对应y发生的概率最大。<br>这个时候，当参数为时，x发生的概率为，结果为x时，参数为的概率就定义为似然函数，所以如果有一组数据，最大似然函数则为：</p><h1 id="奥卡姆剃刀"><a href="#奥卡姆剃刀" class="headerlink" title="奥卡姆剃刀"></a>奥卡姆剃刀</h1><p>相对于最大似然估计比较的大小。<br>而奥卡姆剃刀认为P大的占优势。<br>应用在拟合上面的例子就是平面上N个点进行线性拟合，用N-1次的函数一定可以完美拟合，但是次方数越高也就意味着这个函数越不常见，P越小。<br>这样就避免了过拟合的情况。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EM算法</title>
      <link href="/2022/10/12/EM%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/12/EM%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Initial-Values"><a href="#Initial-Values" class="headerlink" title="Initial Values"></a>Initial Values</h3><p>首先假设我们有数据：x1.。。。xn<br>假设共有两类数据，我们可以对数据的Initial Values进行猜测。<br>猜测值：$\mu_{10}\mu_{20}$；$\pi_{10}\pi_{20}$ ；$\sigma_{10}^{2}\sigma_{20}^{2}$<br>其中$\pi_{10}\pi_{20}$为数据的先验概率。$\mu$和$\sigma$为数据遵循的高斯分布参数。下标的0代表着最初的意思。</p><h3 id="E-step"><a href="#E-step" class="headerlink" title="E-step"></a>E-step</h3><p>在此开始算法迭代。<br>首先对于每一个数据xi，计算出他们对应每个类的ric.</p><script type="math/tex; mode=display">r_{ic}=\frac{\pi_{c0}N(x_{i};\mu_{c0},\sigma_{c0}^{2})}{\pi_{c0}N(x_{i};\mu_{c0},\sigma_{c0}^{2})+\pi_{c'0}N(x_{i};\mu_{c'0},\sigma_{c'0}^{2})}</script><p>下标的i代表着x1-xn的第i个数据，c代表类别，c‘代表另一类别，假设当前c为1类，c’为2类。<br>运用这一公式，我们算出了每一个数据对应每个类的r值。<br>r11,r12,r21,r22,…,rn1,rn2</p><h3 id="M-step"><a href="#M-step" class="headerlink" title="M-step"></a>M-step</h3><p>使用E-step得到的r值，我们可以对初始值进行更新。</p><script type="math/tex; mode=display">\pi_{knew}=\frac{\sum_{i=1}^{n}r_{ik}}{n}</script><script type="math/tex; mode=display">\mu_{knew}=\frac{\sum_{i=1}^{n}r_{ik}x_i}{\sum_{i=1}^{n}r_{ik}}</script><p>协方差矩阵：</p><script type="math/tex; mode=display">\sum_{knew}=\frac{\sum_{i=1}^{n}r_{ik}(x_i-\mu_k)(x_i-\mu_k)^T}{\sum_{i=1}^{n}r_{ik}}</script><h3 id="比对"><a href="#比对" class="headerlink" title="比对"></a>比对</h3><p>将M-step得到的新值和初始值做对比，如果差值小于等于自己设定的阈值，则算法结束；如果差值大于自己设定的阈值，则将新值作为新的初始值，带入E-step循环计算，直到新值结果小于阈值。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 模式识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于最近邻分类的手写数字识别</title>
      <link href="/2022/10/12/%E5%9F%BA%E4%BA%8E%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
      <url>/2022/10/12/%E5%9F%BA%E4%BA%8E%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>以下皆为手写数据库的举例。<br>介绍一下一个简单的实现手写数字识别的方式——最近邻。</p><h3 id="基于PDF的机器学习模型"><a href="#基于PDF的机器学习模型" class="headerlink" title="基于PDF的机器学习模型"></a>基于PDF的机器学习模型</h3><p>假设我们有一张28<em>28大小的手写数字图片。<br>则输入$X=R^{28</em>28}$，得到输出Y为0-9的标签。</p><script type="math/tex; mode=display">f:X->Y</script><p>f 即为我们需要的分类方式。</p><h3 id="图片预处理"><a href="#图片预处理" class="headerlink" title="图片预处理"></a>图片预处理</h3><p>我们一般拿到手写数字的图片是灰度图片，拥有28<em>28=784个像素，每个像素拥有$2^8=256$的深度(彩色)信息。这里插一嘴，人眼其实只能分辨10种颜色梯度，约等于$2^7$种，但是为了方便计算机运算，规定像素的色彩梯度为$2^8=256$。<br>拿到图片之后，将其转成784</em>1的列向量。</p><h3 id="最近邻"><a href="#最近邻" class="headerlink" title="最近邻"></a>最近邻</h3><p>首先我们有一组已知$Y$标签的数据库${X}’$。<br>运用欧氏距离进行计算：</p><script type="math/tex; mode=display">\left \{\left \| X-{X}' \right \|=\sqrt{\sum_{i=1}^{784}(Xi-{Xi}')^{2}}\right \}min</script><p>其中$Xi$为单张图片的每个像素点的值，${X}’$为数据库，一般有几千上万个。<br>这种方法的本质可以抽象成计算未知和已知数据的空间距离，理所应当距离哪个已知数据越近，未知数据就应当被分类为这个已知数据。</p><h3 id="平均最近邻"><a href="#平均最近邻" class="headerlink" title="平均最近邻"></a>平均最近邻</h3><p>上述方法在实际运用时需要对比大量数据。所以引入平均最近邻的思想。<br>首先将已有的数据库进行分类均值处理，将每一类的所有图片求平均值，得到均值图片，再进行上述公式计算，这样只需要对比10张图片即可分出结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模式识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速傅立叶变换FFT</title>
      <link href="/2022/10/12/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2FFT/"/>
      <url>/2022/10/12/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2FFT/</url>
      
        <content type="html"><![CDATA[<h3 id="FFT快速傅里叶变换介绍"><a href="#FFT快速傅里叶变换介绍" class="headerlink" title="FFT快速傅里叶变换介绍"></a>FFT快速傅里叶变换介绍</h3><p>当初学习FFT的时候就一直觉得这玩意真的是天才的创造。<br>我们知道DFT的公式:</p><script type="math/tex; mode=display">X[k]=\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn}</script><p>为了方便后续推到，我们一般假设$N=2^{\mu }$<br>上述公式可以拆分成左边的奇数部分和右边的偶数部分.</p><script type="math/tex; mode=display">X[k]=\sum_{m=0}^{\frac{N}{2}-1}x[2m]e^{-j\frac{2\pi}{N}k2m}+\sum_{m=0}^{\frac{N}{2}-1}x[2m+1]e^{-j\frac{2\pi}{N}k(2m+1)}\\=\sum_{m=0}^{\frac{N}{2}-1}x[2m]e^{-j\frac{2\pi km}{\frac{N}2}}+e^{-j\frac{2\pi kn}{N}}\sum_{m=0}^{\frac{N}{2}-1}x[2m+1]e^{-j\frac{2\pi km}{\frac{N}2}}\\</script><p>将奇数部分和偶数部分分别记为$Xeven[k]$和$Xodd[k]$得到</p><script type="math/tex; mode=display">X[k]=Xe[k]+e^{-j\frac{2\pi kn}{N}}Xo[k]\\Xeven[k]=\sum_{m=0}^{\frac{N}{2}-1}x[2m]e^{-j\frac{2\pi km}{\frac{N}2}}\\Xodd[k]=\sum_{m=0}^{\frac{N}{2}-1}x[2m+1]e^{-j\frac{2\pi km}{\frac{N}2}}\\k=0,1,...,N-1</script><p>其中$k=0,1,…,N-1$对于每个k,有:<br>$C(k)=C(Multiflication,Addition)=(1,1)$<br>对于所有的k来说,$C=(N,N)$<br>那么接下来将$Xeven[k]$和$Xodd[k]$再次分为奇数项和偶数项$Xee[k]$ $Xeo[k]$和$Xoe[k]$ $Xoo[k]$<br>不断地向下分,直到不能分为止,我们就得到了下面的树状图:<br><img src="https://img-blog.csdnimg.cn/20200304004142974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NjAwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于上述假设了$N=2^{\mu }$,所以树状图共有$\mu=\log_2N$级,我们定义最底层的算法复杂度为$C1$,则最顶端的算法复杂度为</p><script type="math/tex; mode=display">C\mu=(N,N)</script><p>则</p><script type="math/tex; mode=display">C\mu-1=2(\frac{N}2,\frac{N}2)=(N,N) 每组有\frac{N}2个点,共2组\\...\\...\\C\mu-i=2^{i}(\frac{N}{2^{i}},\frac{N}{2^{i}})=(N,N)每组有{2^{i}}个点,共2^{i}组\\</script><p>所以每层向上一层的计算次数都是(N,N)，求和得到总的蝶形运算次数：</p><script type="math/tex; mode=display">C=\sum_{i=1}^{N}Ci=\mu(N,N)=(N\log_2N,N\log_2N)=O(N\log_2N)</script><p>而正常的傅里叶变换为$O(N^2)$</p><p>举个例子说明这是多么大的飞跃:<br>假设计算机的单次计算速度为$T=10^{-8}sec$,共有$N=2^{20}$个数据</p><script type="math/tex; mode=display">Tdft=N^2T=10^4sec=2.8h\\Tfft=N\log_2NT=0.2sec</script><p>差了好多好多倍啊!!!</p><h3 id="MATLAB代码"><a href="#MATLAB代码" class="headerlink" title="MATLAB代码"></a>MATLAB代码</h3><p>matlab有现成的fft2函数来做快速傅里叶变换。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%% Q3 <span class="number">2</span>D-FFT</span><br><span class="line">raw_image=imread(<span class="string">&#x27;hh.jpg&#x27;</span>); % read image</span><br><span class="line">image=im2double(rgb2gray(raw_image));</span><br><span class="line">tic % start counting</span><br><span class="line">F=fft2(image); % <span class="number">2</span>D FFT</span><br><span class="line">toc % stop counting</span><br><span class="line"><span class="title function_">subplot</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span>,<span class="title function_">imshow</span><span class="params">(raw_image)</span>,<span class="title function_">title</span><span class="params">(<span class="string">&#x27;raw&#x27;</span>)</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(F),title(<span class="string">&#x27;2D-FFT&#x27;</span>);</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200302111537421.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NjAwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用时0.001086 秒。超级快。<br>往期相关文章：<a href="https://blog.csdn.net/weixin_43966008/article/details/104585580">二维DFT</a>，<a href="https://blog.csdn.net/weixin_43966008/article/details/104470697">一维DFT叠加</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复easyBCD误删Windows启动引导</title>
      <link href="/2022/10/12/%E4%BF%AE%E5%A4%8DeasyBCD%E8%AF%AF%E5%88%A0Windows%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC/"/>
      <url>/2022/10/12/%E4%BF%AE%E5%A4%8DeasyBCD%E8%AF%AF%E5%88%A0Windows%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>今天给朋友的电脑装Ubuntu双系统的时候不小心用easyBCD误删了Windows的启动引导项。再重启电脑发现能正常进入Ubuntu，但是进不了Windows了，尝试了很多方法进行修复，在这里记录一下过程。</p><h3 id="制作Windows启动盘"><a href="#制作Windows启动盘" class="headerlink" title="制作Windows启动盘"></a>制作Windows启动盘</h3><p>下载一个win10系统。<br>磁力链接:(ed2k://%7Cfile%7Ccn_windows_10_multiple_editions_x64_dvd_6848463.iso%7C4303300608%7C94FD861E82458005A9CA8E617379856A%7C/)，大概要4、5个G，慢慢等。<br>然后用工具将下载好的镜像做成启动盘，我用的是<a href="https://sourceforge.net/projects/win32diskimager/">Win32DiskImager</a><br>在电脑的BIOS里设置U盘启动(不同的电脑型号方法不同,这里不赘述)，进入制作好的启动盘。</p><h3 id="修复BCD"><a href="#修复BCD" class="headerlink" title="修复BCD"></a>修复BCD</h3><p>进入安装界面,点击左下角下一步。<br>依次点击:“疑难解答”，“高级选项”，“命令提示符”。<br>接下来依次输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diskpart <span class="comment">#选中磁盘,再输入list disk，找到电脑系统所在磁盘</span></span><br><span class="line">sel disk X <span class="comment">#选中刚刚自己发现的系统所在磁盘(X自己替换成数字)</span></span><br><span class="line">lis​​​​​​​t vol​​​​​​​ <span class="comment">#查看磁盘里各个盘符，并确定自己的win系统所在的盘符（通常为C盘)</span></span><br><span class="line">list par </span><br><span class="line">sel par <span class="number">1</span> </span><br><span class="line">assign letter=P</span><br><span class="line"><span class="keyword">exit</span> <span class="comment">#退出磁盘管理操作</span></span><br></pre></td></tr></table></figure><p>最后输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdboot x:\windows /s P： /f uefi /l zh<span class="literal">-cn</span> </span><br><span class="line"><span class="comment">#盘符x:是你自己刚刚确定的盘符,最后的/l是小写的L,不是1</span></span><br></pre></td></tr></table></figure><p>如果提示创建文件成功，就说明修复完成了,关掉代码界面选择”退出并继续windows10”，至此完成修复。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暴力计算二维DFT</title>
      <link href="/2022/10/12/%E6%9A%B4%E5%8A%9B%E8%AE%A1%E7%AE%97%E4%BA%8C%E7%BB%B4DFT/"/>
      <url>/2022/10/12/%E6%9A%B4%E5%8A%9B%E8%AE%A1%E7%AE%97%E4%BA%8C%E7%BB%B4DFT/</url>
      
        <content type="html"><![CDATA[<p>本篇直接对图片使用二维DFT公式，意在与两次一维DFT叠加的方式做对比。<br>二维DFT公式：</p><script type="math/tex; mode=display">F(u,v)=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi(\frac{ux}{M}+\frac{vy}{N})}</script><h3 id="MATLAB代码"><a href="#MATLAB代码" class="headerlink" title="MATLAB代码"></a>MATLAB代码</h3><p>直接用四层循环嵌套实现公式的计算过程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%% Q1 <span class="number">2</span>D-DFT</span><br><span class="line">raw_image=imread(<span class="string">&#x27;hh.jpg&#x27;</span>); % read image</span><br><span class="line">image=im2double(rgb2gray(raw_image));</span><br><span class="line">[M,N]=size(image); % get the image size</span><br><span class="line">T=zeros(M,N);</span><br><span class="line">tic % start counting</span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span>:M % <span class="keyword">for</span> every row</span><br><span class="line">    <span class="keyword">for</span> y = <span class="number">1</span>:N % <span class="keyword">for</span> every column</span><br><span class="line">        <span class="keyword">for</span> u =<span class="number">1</span>:M</span><br><span class="line">            <span class="keyword">for</span> v = <span class="number">1</span>:N</span><br><span class="line">                E = <span class="built_in">exp</span>(<span class="number">-1</span>i*<span class="number">2</span>*pi*(((u<span class="number">-1</span>)*(x<span class="number">-1</span>)/M)+((v<span class="number">-1</span>)*(y<span class="number">-1</span>)/N))); % get <span class="built_in">exp</span> kernel</span><br><span class="line">                <span class="title function_">T</span><span class="params">(x,y)</span> = T(x,y) + image(u,v)*E;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">toc % stop counting</span><br><span class="line"><span class="title function_">subplot</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span>,<span class="title function_">imshow</span><span class="params">(raw_image)</span>,<span class="title function_">title</span><span class="params">(<span class="string">&#x27;raw&#x27;</span>)</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(T),title(<span class="string">&#x27;2D-DFT&#x27;</span>);</span><br></pre></td></tr></table></figure><br>用我最喜欢的憨憨龟来测试</p><p><img src="https://img-blog.csdnimg.cn/20200302110900321.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NjAwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>用时1081.484753 秒，可以说是最憨的一种实现方式了。<br>另一篇文章介绍了<a href="https://blog.csdn.net/weixin_43966008/article/details/104470697">一维的DFT叠加方式</a>实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/09/hello-world/"/>
      <url>/2022/10/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用一维DFT叠加实现对图片二维傅立叶变换</title>
      <link href="/2020/03/01/%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4DFT%E5%8F%A0%E5%8A%A0%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%9B%BE%E7%89%87%E4%BA%8C%E7%BB%B4%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/2020/03/01/%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4DFT%E5%8F%A0%E5%8A%A0%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%9B%BE%E7%89%87%E4%BA%8C%E7%BB%B4%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>使用两次一维DFT的叠加方式实现二维的DFT运算可以有效的减少计算成本。</p><p>一维DFT公式</p><script type="math/tex; mode=display">X[k]=\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn}</script><h3 id="将DFT转化为矩阵运算"><a href="#将DFT转化为矩阵运算" class="headerlink" title="将DFT转化为矩阵运算"></a>将DFT转化为矩阵运算</h3><p>在MATLAB中，使用矩阵运算比循环更加有效率。下面展示对每一行的处理：（以256x256大小图片举例）<br>对第i行进行DFT处理，则第i行第一个元素的卷积为：<br>$x[i,1]e^{-j\frac{2\pi}{N}0<em>0}+x[i,1]e^{-j\frac{2\pi}{N}0</em>1}+…+x[i,1]e^{-j\frac{2\pi}{N}0*255}$<br>所以将每行的每个元素都进行此运算之后得到：</p><script type="math/tex; mode=display">X[i，1]=x[i,1]e^{-j\frac{2\pi}{N}0*0}+x[i,1]e^{-j\frac{2\pi}{N}0*1}+...+x[i,1]e^{-j\frac{2\pi}{N}0*255}\\X[i，2]=x[i,2]e^{-j\frac{2\pi}{N}1*0}+x[i,2]e^{-j\frac{2\pi}{N}1*1}+...+x[i,2]e^{-j\frac{2\pi}{N}1*2}\\...\\...\\X[i，256]=x[i,256]e^{-j\frac{2\pi}{N}255*0}+x[i,256]e^{-j\frac{2\pi}{N}255*1}+...+x[i,256]e^{-j\frac{2\pi}{N}255*255}</script><p>所以对于图像每一行组成的行向量，指数部分就是：<br>第1个元素：$0<em>0+0</em>1+…+0<em>255$<br>第256个元素：$255</em>0+255<em>1+…+255</em>255$<br>这种加法刚好就构成了一个向量和一个矩阵的乘法过程。</p><p>我们构建一个由0到255的列向量和0到255的行向量相乘得到的255x255大小的矩阵。姑且叫做EMatrix。</p><script type="math/tex; mode=display">e^{-j\frac{2\pi}{N}}\begin{bmatrix}0\\ ...\\ 255\end{bmatrix}*\begin{bmatrix}0 & ... & 255\end{bmatrix}=e^{-j\frac{2\pi}{N}}\begin{bmatrix} 0*0& 0*1 & ... &0*255\\  ...&  ...&  ...& ...\\  ...&  ...&  ...& ...\\  255*0&  ...&  ...&255*255 \end{bmatrix}</script><p>所以对于图片的每一行，第一个元素会对应乘上矩阵的第一行的每个元素并相加，得到对应的第一元素的X[k]，将每一行都乘以这个矩阵就可以得到对图片进行行处理的结果。</p><script type="math/tex; mode=display">X[i,:]=x[i,:]*EMatrix=\begin{bmatrix}x[i,1] & ... & ... & x[i,256]\end{bmatrix}*e^{-j\frac{2\pi}{N}}\begin{bmatrix} 0*0& 0*1 & ... &0*255\\  ...&  ...&  ...& ...\\  ...&  ...&  ...& ...\\  255*0&  ...&  ...&255*255 \end{bmatrix}</script><p>下一步就是对图片的每一列进行相同的步骤，不过注意列向量拿出来之后需要转置再乘EMatrix再转置得到对应列的结果。</p><h2 id="MATLAB代码"><a href="#MATLAB代码" class="headerlink" title="MATLAB代码"></a>MATLAB代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%% Q2 <span class="number">1</span>D-DFT</span><br><span class="line">raw_image=imread(<span class="string">&#x27;hh.jpg&#x27;</span>); % read image</span><br><span class="line">image=im2double(rgb2gray(raw_image));</span><br><span class="line">[M,N]=size(image);</span><br><span class="line">one_d1=zeros(M,N); % x-dimention</span><br><span class="line">one_d2=zeros(M,N);% y-dimention</span><br><span class="line">k=<span class="number">0</span>:<span class="number">1</span>:<span class="number">255</span>; </span><br><span class="line">n=<span class="number">0</span>:<span class="number">1</span>:<span class="number">255</span>;</span><br><span class="line">kn=k<span class="number">&#x27;</span>*n; % get <span class="built_in">exp</span> kernel</span><br><span class="line">E=<span class="built_in">exp</span>(<span class="number">-1</span>i*<span class="number">2</span>*pi/<span class="number">256</span>).^(kn);</span><br><span class="line">tic % start counting</span><br><span class="line"><span class="keyword">for</span> a=<span class="number">1</span>:M % <span class="keyword">for</span> every row</span><br><span class="line">    one_d1(a,:)=image(a,:)*E;</span><br><span class="line">end</span><br><span class="line"><span class="keyword">for</span> b=<span class="number">1</span>:N % <span class="keyword">for</span> every column</span><br><span class="line">    one_d2(:,b)=(one_d1(:,b)<span class="string">&#x27;*E)&#x27;</span>;</span><br><span class="line">end</span><br><span class="line">toc % stop counting</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(raw_image),title(<span class="string">&#x27;raw&#x27;</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(one_d2),title(<span class="string">&#x27;1D-DFT&#x27;</span>);</span><br></pre></td></tr></table></figure><p>用我最喜欢的憨憨龟来测试一下</p><p><img src="https://img-blog.csdnimg.cn/20200227081919736.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NjAwOA==,size_16,color_FFFFFF,t_70" alt="憨憨"></p><p>用时0.014302秒，相比于直接用公式计算2D的DFT要快非常多。</p><p>提到傅里叶变换就不得不提到<a href="https://blog.csdn.net/weixin_43966008/article/details/104585595">快速傅里叶变换FFT</a>，在我下一篇文章里有介绍。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>catographer安装教程</title>
      <link href="/2020/02/28/catographer%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2020/02/28/catographer%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="cartographer的安装与配置"><a href="#cartographer的安装与配置" class="headerlink" title="cartographer的安装与配置"></a>cartographer的安装与配置</h1><p>参照<a href="https://google-cartographer-ros.readthedocs.io/en/latest/index.html">cartographer官方手册</a></p><p>按照cartographer的官方手册是完成不了cartographer安装的，主要是其中的ceres库无法下载（原因很简单。。大家都知道一些著名网站在大陆是不存在的）。在这里特地整理了一下安装步骤：<br>先安装依赖：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y google-mock libboost-all-dev  libeigen3-dev libgflags-dev libgoogle-glog-dev liblua5.2-dev libprotobuf-dev  libsuitesparse-dev libwebp-dev ninja-build protobuf-compiler python-sphinx  ros-kinetic-tf2-eigen libatlas-base-dev libsuitesparse-dev liblapack-dev</span><br></pre></td></tr></table></figure><br>按照官方手册前几步：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y python-wstool python-rosdep ninja-build</span><br></pre></td></tr></table></figure><br>接着创建工作空间，注意不要和已有的工作空间重名，否则后面会出现bash文件无法找到路径的情况。这里创建空间名为cartograph_ws。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir cartograph_ws</span><br><span class="line">cd cartograph_ws</span><br><span class="line">wstool init src</span><br><span class="line">wstool merge -t src https://raw.githubusercontent.com/googlecartographer/cartographer_ros/master/cartographer_ros.rosinstall</span><br><span class="line">wstool update -t src</span><br></pre></td></tr></table></figure><br>到了这一个wstool update -t src 的时候不出意外会报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://ceres-solver.googlesource.com/ceres-solver.git/&#x27;: Failed to connect to ceres-solver.googlesource.com</span><br><span class="line">port 443: 连接超时</span><br><span class="line">Exception caught during install: Error processing &#x27;ceres-solver&#x27; : [ceres-solver] Checkout of https://ceres-solver.googlesource.com/ceres       -solver.git version 1.12.0rc4 into /home/jack/catkin_ws/src/ceres-solver failed.</span><br></pre></td></tr></table></figure><br>这个时候打开src文件夹会发现已经下载好了cartographer和cartographer_ros，就差ceres库。</p><p>输入以下指令用第三方资源下载解决：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ceres-solver/ceres-solver</span><br></pre></td></tr></table></figure><br>看一下文件夹，保证下载的ceres-solver在src文件夹中。<br>然后继续按照官方手册步骤：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/cartographer/scripts/install_proto3.sh</span><br><span class="line">sudo rosdep init</span><br><span class="line">rosdep update </span><br><span class="line">rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y</span><br><span class="line">catkin_make_isolated --install –use-ninja</span><br><span class="line">source install_isolated/setup.bash</span><br></pre></td></tr></table></figure><br>至此cartographer安装完成。</p><h1 id="仿真demo测试"><a href="#仿真demo测试" class="headerlink" title="仿真demo测试"></a>仿真demo测试</h1><p>首先下载cartographer的2D地图测试包,随便下载一个2D 的就行（跑官方demo完整运行时间一般为半个小时到1个小时之间）：<a href="https://www.ncnynl.com/archives/201810/2783.html">这里</a>有一些2D测试包</p><p>仿真测试之前，如果你之前对PC和turtlebot进行过联机的话，需要将之前在bashrc文件里用来ssh远程登录的语句注释掉，再source一下bash文件。</p><p>进行仿真测试：启动demo演示，顺利的话就可以看到rviz启动并开始建图：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch cartographer_ros demo_backpack_2d.launch  bag_filename:=路径/XXXX.bag</span><br></pre></td></tr></table></figure><br>上面的语句为<code>roslaunch+XXXX.launch+bag_filename:=路径/XXXX.bag</code>具体的launch文件可以自己写，这里不多做介绍。<br>官方提供了很多写好的launch文件，路径为：<code>cartographer_ws/src/cartographer_ros/cartographer_ros/launch/</code><br>保存地图，结束测试。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun map_server map_saver -f ’file’</span><br></pre></td></tr></table></figure></p><h1 id="枯燥无味的算法运行视频"><a href="#枯燥无味的算法运行视频" class="headerlink" title="枯燥无味的算法运行视频"></a>枯燥无味的算法运行视频</h1><p><a href="https://www.bilibili.com/read/cv3103182">av40133675</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
