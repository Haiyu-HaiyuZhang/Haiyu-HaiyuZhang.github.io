<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度学习的一些理解</title>
      <link href="/2022/10/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
      <url>/2022/10/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="wrong password, try again" data-whm="抱歉, 这个文章不能被纠正, 不过您还是能看看解密后的内容">  <script id="hbeData" type="hbeData" data-hmacdigest="233ebee33ef5dd8d96a179611d984836e361ead6f6b45044821e3c0b9f5f3417">77a66e571ed3e10db7162b0ad19abb5913c246d190a813d77e96f9bf5af26f4a608aba4a2e16ec46bc042cca46ae224dabf645afb747a261e864fb88902f83043151be56fb276e365ccc84c22eb7576b0623cd4b5c6aac963abbb102a2aa79e09dcde91414e57edd1d2070c25f660048afd9d07f3a35f899a8b1248cd51cd82335834a41e30bf383aeb8cd7d9d2d7387c39b14f2445c9d0ce741f663258e0620bc2e2c74f68c9fe8d40259ee65ed897a06c05d9267c9797f75e2b5e4104531bd7edcc875840ddf2f3dc440e0c99a10beb34e8bde321281cafafc67281f36ff1bd89e80fb03235d0ded99f6ec4c0a626334eb63e79ff7892870391ee28139e1c9417e96dc5dbc1c673fbf3ef129d39f2d90012c49209549f92d02f0d8ecf5ec16d01c3a7a1d42f9f3138b47e1115d67829428b4d82ee7d99171eda1cda3c528b8ef89b21bade687f9c46107b0505c050a8aaf2d3e0aa360e90ab14ea24f7e3c4f13c2f99c368984afb3df5b82089a4c96c8344c3293acb62ee5132f66882f217707ca27815e49e359602e13bede4f4677b00da96c5d093aaf706beab410ef9693f43180a00c2bbafbdd7ae639ff63dd6857a705ceaba337c112858d2a8607a97bc8bea2c4289b3e549bc5ac246438c678a9e02591a13f6fdcf0e6e17d1837d5ca7c330dd70e4db335a3d39744682b60e705587486771e084a02a8da84342734467894b99a541b0104202d90bc58b0aced9ead587494d66e702fcad7a69c84744ac7f78bc59d40b412f56e4863b570c8f8b3d039724f8410867ba84bd198fe46d7ec4718f43746af4aab39337b7d797910587571a2a81a27227118a3ce20f474dd11fd3ae2b7b9edf07c62a01bffc9cf49794289c174d79572c255439bfa424c722646946256e1a12218d00d29f7f2dbf9a02405eb9c0ffd3e8f2cb8f2e8f73ffee29ae60270790c685259883aa2e9cb90dcdd368e7ca913d78e4f65e23ef370e386aa8022bcd9b407655fdec8522e0a4840a0be6f91d9a31ef9aa5a93bd672481a4d8da54219ee3b0731bb3eee3e9e339021a93e1d22d3f40ce422a09156574b9f4671629e4c761a58d752cb81fc2bb79d492099e89ed7a5dadc6763c28fc934cd0a5ed2a9e08bbe188bcb022a45a1c360ea7fc05baf6ddc234640b53e4659966d27a56690f04a1a31234c91d1e87c7e91cd185488454e35d8585b722db5f0aef2181e215d68d935ef45ce24247da5e13ef8063089510c9294163a961fe6a6d4a5a06c5be9be614878b6a9e9671f033cc7ec6d6a0742ba29308a7ae20e55d47800558099519b614075386c649444ed6feb8d7ec3a4f43524ec6fb436ceaf568894a6b3469519a7e9b60bde5a858733209a41575e95764690fc7328713605e25b8a98bac64b022857000dc71ebe262fa49fb24829cdd8400087caac5bdcac32b95714e32f3c3196d2f68fe2856dce375dfb69f6921b8e3922eaeb90883245eed86fd93a15836997bcd517fcf051e6c9f0c84b4aa5d72372b7fd297065303e33aaf90419daf4a6d3775494f9c2434cd44f16e778cfcdf6279c905308ff322a09c5cdbb4112db5c1a2fb3fbd88198073a71ed33e445bdd2975ae930f338166de40c540b7636b535df0bbbe63f0a8710f0ab5b0c6626c32d2e3b116ac24623bf152430fdd11a0c30f1ce7133778f7ca77abdc16ecb6beafb32401834ca21d078ee6fc9b4fa1bed9a189cdbd14e0e533813d7528fe579cbeb044a85353041bfa145f6ca51972b3f303abd4a990af8e5570dcda42d2484089ae9be9752f6054a2a4a6449b0bb91a36bd660c0583bc7ea0361a4247bf6ba34e0bbda8428693e976a41a9d796dfc6dcb471cecaa402f5344a7d6d5fa4446322ad6a0b6182a6c1200f24ee8c78b200d36a54148d43621668dd6058bb841f61f07b3b59788d0b2ba8124d555418746c440d3db6c7305c8c463a3a7e192713d9af1dce597b0ddc3ca5f48297184e318bff3dbfbcba54a2b7e7bb1cf277b3117cbf580fae485a20c89f0b78dfb7ebf379ad2668aa6cfd3f9a14c66d799c22b630735992b86f5e1638e334458aff21773cf5a300cdd5a0d65575b684b09d4b41c98e94a47a6124aad20f343307b3691454f8aa848c81ec11530f129e2925a880ac356f46003028022caec1eabe24e7aa0408f9c93f5391f1acb7aae1513a503b2562ff8fb286781c24aac7136ea808c1dfa27f93c989eebfe311b6066312b5c62f0f363c31f67099a61d6faafe7992a38346dff2a403ae00076548714de96d5c35e73c4a706eab8a4e8b3e29908bb9aa7d729e3e08f3e885d654810ee7a5d30a7cba926c39780983d68013b0e5b91e628019e577190bde897b185d7ac6a3a62306bd80b39bc5e178468787c3b7a9a9fb2690cef433449f49e7b4282a3a522177bf0eefcd6292239426bf8357c75d20d28f1006a668cf1b2496cf91e28bc116e7ffc5fbaabf253f78f628f48506a711aa3ddf755c751a0a2e0f4738b8fb92a6c21f070b73347bc9a4ddebe62a79d67f55a587bbddc9ebf0b349205ac6cf163a3eaa1d6c6fea145f9700dec29b1f5d2a6b2fabf3b84ed4b075aab7694ddd227ce278218d29d847d7326450ef815c515be6fa8b7a8de3b5af2114bf6288a50802776d1efe8bed643c70e13d347673704db2fd5e19dc3cc57f6b8fa7d2d937869e5fc77f9d550b78dac3cb47892e5ab11ff8dd782633664237261ec6400438e415321fc5a9b842d37d24008c190b74e8dfebad9413f5ab0ef985c7b594ba824334f041ae96b20a9c4c219978acf602699d06a723bb69a11c892b5e17baea8e013f366c5d3e7a88733ef30793e64c277aeff28b37304718775c6c266cb9aa97be8c447f2407a40f3637aba8397f497f735d926cc3b4418866c6ba2e04684bc2cd42efed50e43d4bb1caacaddf674c1bc9ad69a61e5bd54f59f00bfaee0135ad51ab7f7ed49d1cf2d667892c0430c7173df0cc795ca5e9175b029abce86c3b999cd6e3d219920b3dd4a236cddb105b1034692ad22032dc2a871a1f47a7f342db663cd4a0e11b18174f8dcdb26379fbe4ca7367ecc7b54b2d6fd7879cb1a26b1e2838eaf424526e5e34477fe03b50b9c559e6867ddb34787ee1372e1777b2b7a75534adfc50b1cd031cb3d7de8153706c11d64640ab69fa632e297f2e356b8dc4e278c583fed620c18f8749442488acfa1fbad170c57f8f75209f824fd94c6d63c085a9137226117ce9c2a049362d8b46689b0414d210d59395c67a045ca4b06a812603879b268bc188ae647429d7ae5e5672614c7f932267b6bb7f443fab30599eb2e8d511ef32165d7752d0aead8ee4e363dbc4eb97ef9e1b2e3faada55302e12468f477a6506de26f5648b2ccf52c3b5c59f21e6fff0d507f76c5fb8f492b2b1cb4d6e0e5b9bdb40f7f62979e83a1afc9c71b8d2439e5c741785fc08d12c0fdc91ba44ff1925fc9e560f1052731b2209eca65e28b06d99a78175bddffdcfe6622a628bc445b47edf2d1e8bf77fc3b156ddd0d02bd701ef9d51912d6e38ed6be3e49fb6539ffd5b0f718be90d00278338ad8f2677ff52d0731803e9afcfafaca489a0643486fb38023996f4de591b0173fbdbae39e3b60f94b9f99372b6335dcdfe4ecbfa1fe2f9f425a2b48ff84943cafd0a6f191082f571d9c27326c091d28123b643747efa8339a3daf80b293cefd80f2ba75ba2e3c0f899ead8345080d13d738d22e72ddcaf011d899d1dffa90e8b30785e6be98aacb0c4c0feb0e8528546aac4a06f5d648d37f060daa0f16164983048fa5b7c0d1265616b28ac506388ae7b7087ca6ad0ecc31edc362cdcd29fff7a4ba2f6fac9d7982ef9ff4737bc987c6f3fafa85d4a59d3f4e6a4bbfa34ee681a621bf8e0556df29f6445014642b76c0e88c6ee008d58592e9d69d7c1ef3c57338dd6863bbf8394b49944ec537e3f3f6425d3e3caf9905f0873d02b28ee066bc90b296a3db0c87bd4f0c90ddd4048ef31ba6413901b05f64f99bfb1aa1906944e1e619cf385fd565d62ede7eccd140922aa6154cd353381b22f1d856353842f7e9c1f64547b3e15924358cfc472fc76170f124c8b1b7b75b430fcccb314357ebe82eebeeac1c7f0aec32c7772aaf75b819dc59915a1a91531f7f3c14b239adb4186fa61e470ada0c572032767369100f0eb64d2292f9c6bd51d6ef487cfbae10501e9a7f17edb90fe01a26da45d044c362053ee4e931f49e4e24013a6d06bf68332e1cbad4888c809bf008bcc697c8e370343e7dc74c301b869e99ed161b8365587c83d219b921367c07d8fbf67c457e343aabc49063796ad78be9bca821ab62aaf90c380c283c76a56ff7e5d73dff78777245094a193f2a5a3f1d0d27a0ba7195e7e67195e25e6d9b781b44485ff21b9d3a1efc713877f5a14bf9a6e2833b90af8fa3f12d53ee3ee7058067444f4da344fd517df451b87e2f8173d5c950d0ccbde89ccba38ea7f838b8f8d3045450e94245539b27e7ba9c31bf2fa77c38e5b8b2d8cb047ac115de30b6d6facc7938a088651db1701e5dff792f30aafa7429c70b0e78be7e36cc1ea4006a7b8a9fe624010d726614d67731b3203b6739af95859fb230e5abc3eb0853aad044a29b1a05079052f0b12aa489bed7b4a8caa3f224dbef7e693fd23cd6f0fb9a414814deb183a422532166ae804a54d598a2c184df306da0096d6c83b2432d9cd24bae130fb6e1e1e5ff7402092cf1a373b1673d9291a4ab78b349025c70a34a8892ad23ff7e5c444dfa3f3546cb4c1dced9ea2ad04050e6e7bbcd6de5d5aaf172ddd9802169d84e5240b21003651b4cefdbb0f3131d0e6bf649d1e305d478a1d424a806850681119199e4df0957a337c8f6c9ad15090792e2eb5846ce5273378290e7d61a834dbe9c01b5e3f1e6c6f248c0ef72ac1a219431521095b7de97c67081276d8e57803576d4bfcd8b75ca6231ee9d908a99e1ebe5f57210f614404277cb1e88c02276752f31b9718cb6b218b259ef6ecf0c7308b32df37d6b5f46c50a088bd6bec99feb5d93c8728aed1bc7b96ddce8e5fac893c112f8f923f44be00d6111dda54ffc5f6580d28f155fe4cafb9391e4b38bab1b6173ec7580fbbda06282bc4b75cb9bb690c69982d8a8180915f65dc2bdac355b65d552b168a1fc9e3d377f5502aa25eaa75248fb857fec28bebe3310111d1eb56db5d93a7073a0a3860bbb47e32335dc5893f9f13fc3c11bbf5961b01890294295be82843a9f8689ace24edf0d0d1137dbddb309ac87a4f4648973d44a2720c7b5280aac5787810cad6af286b9efa05b6dd88ba8f525a9af9fab5b43927f4fbd8a15a2ace4a15f9da460c036b527c9411ac4d1ff2f809258468041169d7896fb112a90b467592b9178518ec80b7ca80ff7bc1fedca93cd6a509cceb0edb711376b9de74cad85c24ce57f68a05c94ea5f00df3c5bd05c162858ad0a8d6db92ef9e610f911dbf9e5c3855d61504e22d7c24c41574909df779f8b8a980cb606f2a062f83e616d105e573c6f1cff4d4531751ac533d33b64a89c5f69d25e883f50fc6e152e0e0e4fb82a4f3ad5faf4a12dbccf2365f1aded4269a25c16572e74273824f2867c1fcf4d5b89801db66aa6e57acc9b9417ab1878787f620412a6c2608c13d5148db7910c3a774c666b5de566fa94ad413bdeeec708933d10e2362b1b0d94f80f7334bcd0e689665641470d26762ff9f039169eb5138e4751419a3def9234ea8d814be91c5df2958aed56c22ffd3e7a63b248766ef34ed131e04ed3794b9e5e79b14d6d044b6138f4b818564433d9f48ae16c4247f936df62844472e1233b8df795bf2c2105fb41b0dbcb9f65039f96a52aff6c96aafa11e8e3fde9bf5b2ac06fe3a3e26cc423ad9a62ac17e8ee1358973d38f78b16313860ff44c2b82c62951250b5ed90386f6f89e4cd755f569631c9504238fd0dbfe9ec536cb59cac82193850e774e91d6aaab2d27cd60b00f5f0dc0f695d1fb0efd181a7d8c3ead4908ed4990338aa5a3063eb31979f7c2dee67faab9f7d50d9bd05c9120ad180cbf678a601085e0a26e58ab34dd4f8cee7f84b96d114899bc0aed609d53e1aa801a9a8e389df0b85ca51e9edc26d13bf809451b7032ba68a6bdf1da4a07e174e4202575562be537b9aaa135791e83ff4997e993c0ddd26930b7ef789ace1973e101b6c83f89f6bd9561a2b671a02ecf3d7fab072873687caa1de7f8c8bc8af07a76eb1a5f5d2d64cdbe306740438a2fbbec9d410be87c95a01fe537af66b2d790017108ddc651405cee9e69648b252e0d19b319c23453975ff264f5ad54721115a1095d4b636480b7f8478e2754aea2419ca284eed13328526c56dec36dc07ed6c920d9a09f96eeac8c3df2866cc7c17e0c9a07644bbd98a124b6e1a45c02e6e6ad613b84787b550036a56f0b0416c325be03673165d7767e6a575ca1839e1635be610705462e593342006d370f91a29f26c725f78d2f3727f39af14372730870fc0dd59f40ed523d7dd6a801adc6798d9f177c6aa59d3ab657d93657a8c88ac7ca76bc48b653c9ddfdc08f2c0f608446125688a1d447f88f3616c99365827b60e99c935120a4289005d4cd55e0e612b5ecb7307049297c172c3f93cde3352b20bf1756eb0b7eac94f8e7894829416f9d845333acc88c3b497d95fe664be26db344e2f5ca8774c4b16c77888dd961201ed88d27f1a7a843bb095ebfdf862700ea55258715439894ef54b3b5606cc0fe861f36097b8ac9f1520947f40aabb6c1069c1680f1c1107a98cfe7f5e780f1dd6e314f3066f92ff9e9298adce7120c6ebdeb1ec1a2e985c4df1d4787e5f268e78e07db0169df689bbd814d2d4296722dcf0f7396d0b873c6adaf421cefff0c16f5cee1a7fdb1e95f0a5ec0394ef1acbd392d69f4c1966babac9487a56d84ef668b511995031a8ac135347db917ce5af5f4b034726476fc26601dbb455b375f5309ede2cfaf145b9666429c26922fcdc0758e09ebb676be180adddb66fc2860fd4329e84eb7db683400b73be40b0a804240b8a623f137e6a3bc63f463a393ab2fdd8b180a97a4e5758ba4df6c8a88a44e0b6d5af1b85f8a33012155f2f40346a4d118f229818041cd4ed24ba43dbe1194bd10d35cd64f2f2b689fbeddb2fef45a72266e4a4681e3f9042476ac105b2619864bda24183ceff1a7cd2b0dd8d839dd8f8e2c5b877f35ff62c7a3c247f0a879a0a03011f98dc58001252237e1c589bffd392486197d884ffc8582e75f5e1ab8fe9112ab7677ed74b0b8a5062e67c0763af26ad158e88e18226fa1ee7952280d3082ed3d7e791dd6611368778dff90144ff4535d25b55748e31482e68c041abce7b183761c1bfed8a55a0ef0e462c12f35af2f000ae5a953d492f973d2eca848ddb649009a223f70cd7066c28a7bd3afd1baafd954ae585e1870cd03cc1f3b8122681807d1a09187fd76ebb1814d735102e7fa74779b896a6a8d5aa2a4d069e6e69451ad4e918f14c830029f8438722df4cdd8f267b05a49e245c0ee0cfc75ed7d99d8503ec3a3c12cb91286d52daccddf3c2738396043d4481a17ec9f8c9cbff246ee32235137e7b9a926297c9f5c8c66d86c5e90e0ccc45863f8c2589a2807adbb94658d78bdb5c7fdc0d82f07a60499b04ef13427eaee33a7686d16e94ba732a8a5c0bb91a6c49d1816b0b0fa54be1f9462c8c21b1bd50686acd627e4af1342cf888f975817f3ef974761acc3b7971a52b40a4a312d0265751bf9f6a446ce973a2c3383efe50a11661683cc234db51f943a23fee6b03ee852ee13f43f777085f91929ec0ebf6bd641bb2549085d761a664068c1d5ffa66ac1703e9b225b2ebdd1fbce970680ab7252491b89b8bb80aa0b41a389a39062f650a19a14f18e8b24dd7429f6d8f236d3bd52497608fae0240d7d74210069fad76d8fb453e9a38833dd8d502acc980eb84d9126ff361e1e1bfab6e5bdf52f3232d5de032c8b883eff48a83212f22c2a264613d98040e4f48134a13b490ea84825dd8fccc936a1f5eb83119e46d9161599a15e264a3a78fd5ea561e4e1e0205219e005ace9e5389bcd05d18661ed190babd2086c31aeaa11edf748ea2fffda459935b172f7f7487ed56a37b556b50a0e8672f1457839dfd20e2118ac4c779f3901f05542f777c5c679e453138182fce56656e093dece5e75878c994a26f65a53aca37c70d95b289a0d8a376eb6931ef846376a0d3abeb203dba59aa2ad6220b608b3d2d6f572aeaaca55a3007f85aa7e50bff854445016a151e0855863c815ab958fa17365de246720254f7a73df9c8e6d1016cd1025b5e816404588ab28bd5ac4cc08f6a88d3fed5920c4debb820bbcee62ef0f76ca03f741efaee4dd2fe74c40b60b02065eebee4c6a6b358a23f83c1da0d61bd610c575ac47808c3395c438c6200f69a3bd169fb9d880d6849de352f1cf5a3cceae17f286096c705002c7359a94353cb1740a9563dd1c1e7a13e3a7787ad453836b2f659d4559a17b2c0d855c72c17aaca1afc25b21e0684ce99ba147315dcbcc325f6a952e6cc8ad97363fbaaacbe951d89eb13d45392c48c0e6e5943c61c752f06b93f57cc0cb1dc7e866e6859d0a55a4ead7888f3eea7f9b2e44c48d9dfb46172126718b5a82412e286ae2e3a076035f0b059aef9ada309b7b15df7edbfbabb65c6975a7580120d2370582e6dae917bc3ffd79c9ee0abaf1345aa82e83320f567790700430c13771324101471d827d1d42e7dd9c807245d75231137746a6226f4c9bff3fab6dba02a6aac7483e2989996b97ba2915fa8694dd91c9ce6baee558290cc8d883853a0c8e71deadb91ada7e5fb71e2dae6dc06a9e66c872728a0a0908b26f517a91351689f0b978832d2cc8c42703fc493bd30727104f2ae2d8075c8063d481c7101e34c3a89c80b25c487238f65367c83d7be81519e0d9339e46325fad477c9d1c4e112fa9ffba015ac54ab8395942a1d1f8b6eb82f82d43387e6cd316080a6957782211b7ef683c42cc226ed076aa029ccf2641b3a6d25a25b2cf1c9c1c3c90e66352a0a63cb5e89d802c4c3ae8d9ce7a986c91704b581a13ea6e47b01d9119a15cc909d37b825a37da836d8da338e7eb620c511fa195a71f2afe3ec7d212a5e428b787a7bb0b6d76cc4df350047fb0d19f0c07956161b392852d857ab16d60d96c757ab5dfc497c498d7202aa97faba48581151a2397e5d033083fa8bd84c6215967381769d8163f4f8f88fb7fbc93487ae9e8517ae29e82e7c25fe1c2857b6de3b4fcd4c438a8349af02304591f424408efd38616ab24d7b542269529f11f401f83b9b198cb8c16d108342ad5ac4772f889bdabf6ee2427c76a021bb5491984a4cd41bc6d6c5b02c7840d4f07e23318bf620e2b1d68c25ec39bf4a7cd46f4e9871c50dd84d072d6591bc4e3405ad2e3b114e1ce5b8e0d4ef170706a9f05e277ec14c8b25b12784362d5cc1e808e36fd18a35ede84e0e5ea67bcd221824ac2cd2199ee58fe98ffb75c5c0c67bd5b1b0433735ded7c5da4ccee28e6c74e2677a6724f23a0584c03459077b959a684184654678bf4921a9999340f2b7a8aa9d176d3c7c5f7a7d714d3f78f0db720f72d24b0ca7417611a87804bc6a0e2c09829af4c4265fcd54e0e34f684c680a3adabf3395a093c32a24001a704c38b07f7396fa818c997473001ddb9b2dfec33d4e43c63478f07a34cde77c63f698bb360f5792334f2c55f0435fbcf376beea047a284d5e44b2c383b038dfdd7372104ff8ac663686e1e2a4a3c0a38d088b0eadbcc0caa261811da21eb39622a9570e4058a33511c60ddf24c32afefc0afa69bdf616befc5ea5b58d9f587e700fa35de3f0cf2a893e8cb324dba13e024f2f03c51b61e776afd1e667ea6876e62f1d2c91cc99dd09ab46cb6555ed88fc28a7b8d954b9ca840c60b54096faccfa107182a69cd59b8a922eb6aa9019c485bfbf6de78177cd2490c540e196b260a2e9f0f3aa86e79c722c85801ec20e8a62ac349b6f09b7b79b2aa9915e807f959ed2c4daded5844be1bd82c8051af4f277a998edff72359342b9f0756271743c7ef3b355fc7acb849d373dbf1fa77811a220594aae3810425b2ae47dcfa244d2f15977f655cec361f8c02b995b236922ab641c8c0dee83dc9393e025d0a6019eeb51406aff0a2561e5964d183d14f5aa385a25ee6171085b2e04354ac591085733</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">password</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于最近邻分类的手写数字识别</title>
      <link href="/2022/10/12/%E5%9F%BA%E4%BA%8E%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
      <url>/2022/10/12/%E5%9F%BA%E4%BA%8E%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>以下皆为手写数据库的举例。<br>介绍一下一个简单的实现手写数字识别的方式——最近邻。</p><h3 id="基于PDF的机器学习模型"><a href="#基于PDF的机器学习模型" class="headerlink" title="基于PDF的机器学习模型"></a>基于PDF的机器学习模型</h3><p>假设我们有一张28<em>28大小的手写数字图片。<br>则输入$X=R^{28</em>28}$，得到输出Y为0-9的标签。</p><script type="math/tex; mode=display">f:X->Y</script><p>f 即为我们需要的分类方式。</p><h3 id="图片预处理"><a href="#图片预处理" class="headerlink" title="图片预处理"></a>图片预处理</h3><p>我们一般拿到手写数字的图片是灰度图片，拥有28<em>28=784个像素，每个像素拥有$2^8=256$的深度(彩色)信息。这里插一嘴，人眼其实只能分辨10种颜色梯度，约等于$2^7$种，但是为了方便计算机运算，规定像素的色彩梯度为$2^8=256$。<br>拿到图片之后，将其转成784</em>1的列向量。</p><h3 id="最近邻"><a href="#最近邻" class="headerlink" title="最近邻"></a>最近邻</h3><p>首先我们有一组已知$Y$标签的数据库${X}’$。<br>运用欧氏距离进行计算：</p><script type="math/tex; mode=display">\left \{\left \| X-{X}' \right \|=\sqrt{\sum_{i=1}^{784}(Xi-{Xi}')^{2}}\right \}min</script><p>其中$Xi$为单张图片的每个像素点的值，${X}’$为数据库，一般有几千上万个。<br>这种方法的本质可以抽象成计算未知和已知数据的空间距离，理所应当距离哪个已知数据越近，未知数据就应当被分类为这个已知数据。</p><h3 id="平均最近邻"><a href="#平均最近邻" class="headerlink" title="平均最近邻"></a>平均最近邻</h3><p>上述方法在实际运用时需要对比大量数据。所以引入平均最近邻的思想。<br>首先将已有的数据库进行分类均值处理，将每一类的所有图片求平均值，得到均值图片，再进行上述公式计算，这样只需要对比10张图片即可分出结果。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模式识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大似然以及奥卡姆剃刀</title>
      <link href="/2021/10/12/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BB%A5%E5%8F%8A%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80/"/>
      <url>/2021/10/12/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BB%A5%E5%8F%8A%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80/</url>
      
        <content type="html"><![CDATA[<h1 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h1><p>已知一组数据x和结果y，知道或估计到它们的分布模式，假如是伯努利分布，最大似然估计就是可以求出一个参数使得x和y的拟合程度最好。<br>即在参数为的时候，x对应y发生的概率最大。<br>这个时候，当参数为时，x发生的概率为，结果为x时，参数为的概率就定义为似然函数，所以如果有一组数据，最大似然函数则为：</p><h1 id="奥卡姆剃刀"><a href="#奥卡姆剃刀" class="headerlink" title="奥卡姆剃刀"></a>奥卡姆剃刀</h1><p>相对于最大似然估计比较的大小。<br>而奥卡姆剃刀认为P大的占优势。<br>应用在拟合上面的例子就是平面上N个点进行线性拟合，用N-1次的函数一定可以完美拟合，但是次方数越高也就意味着这个函数越不常见，P越小。<br>这样就避免了过拟合的情况。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EM算法</title>
      <link href="/2021/10/12/EM%E7%AE%97%E6%B3%95/"/>
      <url>/2021/10/12/EM%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Initial-Values"><a href="#Initial-Values" class="headerlink" title="Initial Values"></a>Initial Values</h3><p>首先假设我们有数据：x1.。。。xn<br>假设共有两类数据，我们可以对数据的Initial Values进行猜测。<br>猜测值：$\mu_{10}\mu_{20}$；$\pi_{10}\pi_{20}$ ；$\sigma_{10}^{2}\sigma_{20}^{2}$<br>其中$\pi_{10}\pi_{20}$为数据的先验概率。$\mu$和$\sigma$为数据遵循的高斯分布参数。下标的0代表着最初的意思。</p><h3 id="E-step"><a href="#E-step" class="headerlink" title="E-step"></a>E-step</h3><p>在此开始算法迭代。<br>首先对于每一个数据xi，计算出他们对应每个类的ric.</p><script type="math/tex; mode=display">r_{ic}=\frac{\pi_{c0}N(x_{i};\mu_{c0},\sigma_{c0}^{2})}{\pi_{c0}N(x_{i};\mu_{c0},\sigma_{c0}^{2})+\pi_{c'0}N(x_{i};\mu_{c'0},\sigma_{c'0}^{2})}</script><p>下标的i代表着x1-xn的第i个数据，c代表类别，c‘代表另一类别，假设当前c为1类，c’为2类。<br>运用这一公式，我们算出了每一个数据对应每个类的r值。<br>r11,r12,r21,r22,…,rn1,rn2</p><h3 id="M-step"><a href="#M-step" class="headerlink" title="M-step"></a>M-step</h3><p>使用E-step得到的r值，我们可以对初始值进行更新。</p><script type="math/tex; mode=display">\pi_{knew}=\frac{\sum_{i=1}^{n}r_{ik}}{n}</script><script type="math/tex; mode=display">\mu_{knew}=\frac{\sum_{i=1}^{n}r_{ik}x_i}{\sum_{i=1}^{n}r_{ik}}</script><p>协方差矩阵：</p><script type="math/tex; mode=display">\sum_{knew}=\frac{\sum_{i=1}^{n}r_{ik}(x_i-\mu_k)(x_i-\mu_k)^T}{\sum_{i=1}^{n}r_{ik}}</script><h3 id="比对"><a href="#比对" class="headerlink" title="比对"></a>比对</h3><p>将M-step得到的新值和初始值做对比，如果差值小于等于自己设定的阈值，则算法结束；如果差值大于自己设定的阈值，则将新值作为新的初始值，带入E-step循环计算，直到新值结果小于阈值。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模式识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树基础</title>
      <link href="/2021/03/12/%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/03/12/%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树大家应该都见过，直观一点就长下面这样，由根，叶，节点等等组成。</p><p><img src="https://img-blog.csdnimg.cn/20200521060617462.png" width="50%"></p><p>其实一个决策树就是对特征值空间进行了划分。假如使用x1和x2特征进行分类，使用分割值$\theta_1$到$\theta_4$进行分割，实际上就是把空间分成了ABCDE，如左图所示。</p><p><img src="https://img-blog.csdnimg.cn/20200521061022685.png" width="80%"></p><p>构建决策树的关键其实也就是在寻找特征值和分割阈值，即何时选择x1进行决策，以及$\theta$值的确认。</p><h1 id="决策树构建"><a href="#决策树构建" class="headerlink" title="决策树构建"></a>决策树构建</h1><p>构建决策树时候需要尽可能使得构建出的树越小越好，首先引入熵和信息增益的概念。</p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>熵这个概念应该最早是学化学的时候接触到的，用来表示目标的混乱程度。<br>用公式表示就是：</p><script type="math/tex; mode=display">H[s]=-\sum{p\log_2p}$$比如在伯努利分布中,概率分布和为1，即$P_{+}+P_{-}=1$如果$P_{+}=1$，则$P_{-}=0$,此时的熵为：$$H[s]=-P_{-}\log_2P_{-}-P_{+}\log_2P_{+}=-0-0=0</script><p>熵为0代表着结果是确定的。<br>假设$P_{+}=0.5$，则$P_{-}=0.5$,此时的熵为：</p><script type="math/tex; mode=display">H[s]=-P_{-}\log_2P_{-}-P_{+}\log_2P_{+}=1</script><p>熵最大，完全不确定x为正还是负。</p><p>构建决策树的时候也可以用基尼系数或者方差来代替熵。<br>对于特征的一组类别，计算熵的时候需要考虑权重。假设特征A有k个类别，每个类别的概率是$\frac{S_k}{S}$，则对于样本集合A来说熵为：</p><script type="math/tex; mode=display">H[A]=-\sum_{k=1}^{k}\frac{S_k}{S}\log_2\frac{S_k}{S}</script><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>假设结果Y受到ABC三种特征的影响，则我们可以求出ABC三种因素的熵值</p><script type="math/tex; mode=display">H[A],H[B],H[C]$$定义结果Y从A中获得的信息量（info gain）为$H[Y]-H[A]$，信息增益越大也就代表着混乱程度下降越快。所以想要构建最小棵的决策树，我们就需要遵循熵最快下降原则，选取增益最大的特征作为第一个判断原则，这样逐渐的构建起决策树。## 举个例子下图为打球与否和天气情况的关系图，其中天气情况缩写如下，每个特征都对应着不同的程度：Outlook: S(unny), O(vercast), R(ainy)Temperature: H(ot), M(edium), C(ool)Humidity: H(igh), N(ormal), L(ow)Wind: S(trong), W(eak)<img src="https://img-blog.csdnimg.cn/20200521063918770.png"  width="45%">所以按照刚刚讲述的步骤，首先计算打不打球的熵：$$play = 9/14$$$$not = 5/14$$$$H(Play?) = −(9/14) /log_2(9/14)−(5/14) /log_2(5/14)=0.94</script><p>接着计算每个天气特征的熵，这里展示了一下outlook的计算熵过程：</p><p><img src="https://img-blog.csdnimg.cn/20200521064645645.png" width="50%"></p><p>Outlook: 0.246<br>Humidity: 0.151<br>Wind: 0.048<br>Temperature: 0.029<br>当计算完所有的天气特征熵并得到信息增益之后，就可以由大到小构建决策树了。<br>最终构建出的决策树如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200521065045762.png" width="70%"></p><h2 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h2><p>对于某些特征来说，自身的熵很小可能是因为自身发生的概率很小，这样会导致它的信息增益很大，影响决策树的构建，所以可以引入信息增益率来解决这个事情。<br>用信息增益除以本身的因素熵。</p><p>$$$$</p><h1 id="评价函数"><a href="#评价函数" class="headerlink" title="评价函数"></a>评价函数</h1><p>评价函数越小越好</p><h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><p>有些决策树可以实现完全的分类，但是树非常高，不怎么实用。</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><p>构建过程中提前停止，通常可以规定树高或者其他约束</p><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>通过改造评价函数</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>catographer安装教程</title>
      <link href="/2021/02/28/catographer%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2021/02/28/catographer%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="cartographer的安装与配置"><a href="#cartographer的安装与配置" class="headerlink" title="cartographer的安装与配置"></a>cartographer的安装与配置</h1><p>参照<a href="https://google-cartographer-ros.readthedocs.io/en/latest/index.html">cartographer官方手册</a></p><p>按照cartographer的官方手册是完成不了cartographer安装的，主要是其中的ceres库无法下载（原因很简单。。大家都知道一些著名网站在大陆是不存在的）。在这里特地整理了一下安装步骤：<br>先安装依赖：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y google-mock libboost-all-dev  libeigen3-dev libgflags-dev libgoogle-glog-dev liblua5.2-dev libprotobuf-dev  libsuitesparse-dev libwebp-dev ninja-build protobuf-compiler python-sphinx  ros-kinetic-tf2-eigen libatlas-base-dev libsuitesparse-dev liblapack-dev</span><br></pre></td></tr></table></figure><br>按照官方手册前几步：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y python-wstool python-rosdep ninja-build</span><br></pre></td></tr></table></figure><br>接着创建工作空间，注意不要和已有的工作空间重名，否则后面会出现bash文件无法找到路径的情况。这里创建空间名为cartograph_ws。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir cartograph_ws</span><br><span class="line">cd cartograph_ws</span><br><span class="line">wstool init src</span><br><span class="line">wstool merge -t src https://raw.githubusercontent.com/googlecartographer/cartographer_ros/master/cartographer_ros.rosinstall</span><br><span class="line">wstool update -t src</span><br></pre></td></tr></table></figure><br>到了这一个wstool update -t src 的时候不出意外会报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://ceres-solver.googlesource.com/ceres-solver.git/&#x27;: Failed to connect to ceres-solver.googlesource.com</span><br><span class="line">port 443: 连接超时</span><br><span class="line">Exception caught during install: Error processing &#x27;ceres-solver&#x27; : [ceres-solver] Checkout of https://ceres-solver.googlesource.com/ceres       -solver.git version 1.12.0rc4 into /home/jack/catkin_ws/src/ceres-solver failed.</span><br></pre></td></tr></table></figure><br>这个时候打开src文件夹会发现已经下载好了cartographer和cartographer_ros，就差ceres库。</p><p>输入以下指令用第三方资源下载解决：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ceres-solver/ceres-solver</span><br></pre></td></tr></table></figure><br>看一下文件夹，保证下载的ceres-solver在src文件夹中。<br>然后继续按照官方手册步骤：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/cartographer/scripts/install_proto3.sh</span><br><span class="line">sudo rosdep init</span><br><span class="line">rosdep update </span><br><span class="line">rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y</span><br><span class="line">catkin_make_isolated --install –use-ninja</span><br><span class="line">source install_isolated/setup.bash</span><br></pre></td></tr></table></figure><br>至此cartographer安装完成。</p><h1 id="仿真demo测试"><a href="#仿真demo测试" class="headerlink" title="仿真demo测试"></a>仿真demo测试</h1><p>首先下载cartographer的2D地图测试包,随便下载一个2D 的就行（跑官方demo完整运行时间一般为半个小时到1个小时之间）：<a href="https://www.ncnynl.com/archives/201810/2783.html">这里</a>有一些2D测试包</p><p>仿真测试之前，如果你之前对PC和turtlebot进行过联机的话，需要将之前在bashrc文件里用来ssh远程登录的语句注释掉，再source一下bash文件。</p><p>进行仿真测试：启动demo演示，顺利的话就可以看到rviz启动并开始建图：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch cartographer_ros demo_backpack_2d.launch  bag_filename:=路径/XXXX.bag</span><br></pre></td></tr></table></figure><br>上面的语句为<code>roslaunch+XXXX.launch+bag_filename:=路径/XXXX.bag</code>具体的launch文件可以自己写，这里不多做介绍。<br>官方提供了很多写好的launch文件，路径为：<code>cartographer_ws/src/cartographer_ros/cartographer_ros/launch/</code><br>保存地图，结束测试。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun map_server map_saver -f ’file’</span><br></pre></td></tr></table></figure></p><h1 id="枯燥无味的算法运行视频"><a href="#枯燥无味的算法运行视频" class="headerlink" title="枯燥无味的算法运行视频"></a>枯燥无味的算法运行视频</h1><p><a href="https://www.bilibili.com/read/cv3103182">av40133675</a></p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速傅立叶变换FFT</title>
      <link href="/2020/10/12/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2FFT/"/>
      <url>/2020/10/12/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2FFT/</url>
      
        <content type="html"><![CDATA[<h3 id="FFT快速傅里叶变换介绍"><a href="#FFT快速傅里叶变换介绍" class="headerlink" title="FFT快速傅里叶变换介绍"></a>FFT快速傅里叶变换介绍</h3><p>当初学习FFT的时候就一直觉得这玩意真的是天才的创造。<br>我们知道DFT的公式:</p><script type="math/tex; mode=display">X[k]=\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn}</script><p>为了方便后续推到，我们一般假设$N=2^{\mu }$<br>上述公式可以拆分成左边的奇数部分和右边的偶数部分.</p><script type="math/tex; mode=display">X[k]=\sum_{m=0}^{\frac{N}{2}-1}x[2m]e^{-j\frac{2\pi}{N}k2m}+\sum_{m=0}^{\frac{N}{2}-1}x[2m+1]e^{-j\frac{2\pi}{N}k(2m+1)}\\=\sum_{m=0}^{\frac{N}{2}-1}x[2m]e^{-j\frac{2\pi km}{\frac{N}2}}+e^{-j\frac{2\pi kn}{N}}\sum_{m=0}^{\frac{N}{2}-1}x[2m+1]e^{-j\frac{2\pi km}{\frac{N}2}}\\</script><p>将奇数部分和偶数部分分别记为$Xeven[k]$和$Xodd[k]$得到</p><script type="math/tex; mode=display">X[k]=Xe[k]+e^{-j\frac{2\pi kn}{N}}Xo[k]\\Xeven[k]=\sum_{m=0}^{\frac{N}{2}-1}x[2m]e^{-j\frac{2\pi km}{\frac{N}2}}\\Xodd[k]=\sum_{m=0}^{\frac{N}{2}-1}x[2m+1]e^{-j\frac{2\pi km}{\frac{N}2}}\\k=0,1,...,N-1</script><p>其中$k=0,1,…,N-1$对于每个k,有:<br>$C(k)=C(Multiflication,Addition)=(1,1)$<br>对于所有的k来说,$C=(N,N)$<br>那么接下来将$Xeven[k]$和$Xodd[k]$再次分为奇数项和偶数项$Xee[k]$ $Xeo[k]$和$Xoe[k]$ $Xoo[k]$<br>不断地向下分,直到不能分为止,我们就得到了下面的树状图:<br><img src="https://img-blog.csdnimg.cn/20200304004142974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NjAwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于上述假设了$N=2^{\mu }$,所以树状图共有$\mu=\log_2N$级,我们定义最底层的算法复杂度为$C1$,则最顶端的算法复杂度为</p><script type="math/tex; mode=display">C\mu=(N,N)</script><p>则</p><script type="math/tex; mode=display">C\mu-1=2(\frac{N}2,\frac{N}2)=(N,N) 每组有\frac{N}2个点,共2组\\...\\...\\C\mu-i=2^{i}(\frac{N}{2^{i}},\frac{N}{2^{i}})=(N,N)每组有{2^{i}}个点,共2^{i}组\\</script><p>所以每层向上一层的计算次数都是(N,N)，求和得到总的蝶形运算次数：</p><script type="math/tex; mode=display">C=\sum_{i=1}^{N}Ci=\mu(N,N)=(N\log_2N,N\log_2N)=O(N\log_2N)</script><p>而正常的傅里叶变换为$O(N^2)$</p><p>举个例子说明这是多么大的飞跃:<br>假设计算机的单次计算速度为$T=10^{-8}sec$,共有$N=2^{20}$个数据</p><script type="math/tex; mode=display">Tdft=N^2T=10^4sec=2.8h\\Tfft=N\log_2NT=0.2sec</script><p>差了好多好多倍啊!!!</p><h3 id="MATLAB代码"><a href="#MATLAB代码" class="headerlink" title="MATLAB代码"></a>MATLAB代码</h3><p>matlab有现成的fft2函数来做快速傅里叶变换。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%% Q3 <span class="number">2</span>D-FFT</span><br><span class="line">raw_image=imread(<span class="string">&#x27;hh.jpg&#x27;</span>); % read image</span><br><span class="line">image=im2double(rgb2gray(raw_image));</span><br><span class="line">tic % start counting</span><br><span class="line">F=fft2(image); % <span class="number">2</span>D FFT</span><br><span class="line">toc % stop counting</span><br><span class="line"><span class="title function_">subplot</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span>,<span class="title function_">imshow</span><span class="params">(raw_image)</span>,<span class="title function_">title</span><span class="params">(<span class="string">&#x27;raw&#x27;</span>)</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(F),title(<span class="string">&#x27;2D-FFT&#x27;</span>);</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200302111537421.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NjAwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用时0.001086 秒。超级快。<br>往期相关文章：<br><a href="/2020/10/12/%E6%9A%B4%E5%8A%9B%E8%AE%A1%E7%AE%97%E4%BA%8C%E7%BB%B4DFT/" title="二维DFT">二维DFT</a><br><a href="/2020/03/01/%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4DFT%E5%8F%A0%E5%8A%A0%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%9B%BE%E7%89%87%E4%BA%8C%E7%BB%B4%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/" title="一维的DFT叠加方式">一维的DFT叠加方式</a></p>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复easyBCD误删Windows启动引导</title>
      <link href="/2020/10/12/%E4%BF%AE%E5%A4%8DeasyBCD%E8%AF%AF%E5%88%A0Windows%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC/"/>
      <url>/2020/10/12/%E4%BF%AE%E5%A4%8DeasyBCD%E8%AF%AF%E5%88%A0Windows%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>今天给朋友的电脑装Ubuntu双系统的时候不小心用easyBCD误删了Windows的启动引导项。再重启电脑发现能正常进入Ubuntu，但是进不了Windows了，尝试了很多方法进行修复，在这里记录一下过程。</p><h3 id="制作Windows启动盘"><a href="#制作Windows启动盘" class="headerlink" title="制作Windows启动盘"></a>制作Windows启动盘</h3><p>下载一个win10系统。<br>磁力链接:(ed2k://%7Cfile%7Ccn_windows_10_multiple_editions_x64_dvd_6848463.iso%7C4303300608%7C94FD861E82458005A9CA8E617379856A%7C/)，大概要4、5个G，慢慢等。<br>然后用工具将下载好的镜像做成启动盘，我用的是<a href="https://sourceforge.net/projects/win32diskimager/">Win32DiskImager</a><br>在电脑的BIOS里设置U盘启动(不同的电脑型号方法不同,这里不赘述)，进入制作好的启动盘。</p><h3 id="修复BCD"><a href="#修复BCD" class="headerlink" title="修复BCD"></a>修复BCD</h3><p>进入安装界面,点击左下角下一步。<br>依次点击:“疑难解答”，“高级选项”，“命令提示符”。<br>接下来依次输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diskpart <span class="comment">#选中磁盘,再输入list disk，找到电脑系统所在磁盘</span></span><br><span class="line">sel disk X <span class="comment">#选中刚刚自己发现的系统所在磁盘(X自己替换成数字)</span></span><br><span class="line">lis​​​​​​​t vol​​​​​​​ <span class="comment">#查看磁盘里各个盘符，并确定自己的win系统所在的盘符（通常为C盘)</span></span><br><span class="line">list par </span><br><span class="line">sel par <span class="number">1</span> </span><br><span class="line">assign letter=P</span><br><span class="line"><span class="keyword">exit</span> <span class="comment">#退出磁盘管理操作</span></span><br></pre></td></tr></table></figure><p>最后输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdboot x:\windows /s P： /f uefi /l zh<span class="literal">-cn</span> </span><br><span class="line"><span class="comment">#盘符x:是你自己刚刚确定的盘符,最后的/l是小写的L,不是1</span></span><br></pre></td></tr></table></figure><p>如果提示创建文件成功，就说明修复完成了,关掉代码界面选择”退出并继续windows10”，至此完成修复。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暴力计算二维DFT</title>
      <link href="/2020/10/12/%E6%9A%B4%E5%8A%9B%E8%AE%A1%E7%AE%97%E4%BA%8C%E7%BB%B4DFT/"/>
      <url>/2020/10/12/%E6%9A%B4%E5%8A%9B%E8%AE%A1%E7%AE%97%E4%BA%8C%E7%BB%B4DFT/</url>
      
        <content type="html"><![CDATA[<p>本篇直接对图片使用二维DFT公式，意在与两次一维DFT叠加的方式做对比。<br>二维DFT公式：</p><script type="math/tex; mode=display">F(u,v)=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi(\frac{ux}{M}+\frac{vy}{N})}</script><h3 id="MATLAB代码"><a href="#MATLAB代码" class="headerlink" title="MATLAB代码"></a>MATLAB代码</h3><p>直接用四层循环嵌套实现公式的计算过程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%% Q1 <span class="number">2</span>D-DFT</span><br><span class="line">raw_image=imread(<span class="string">&#x27;hh.jpg&#x27;</span>); % read image</span><br><span class="line">image=im2double(rgb2gray(raw_image));</span><br><span class="line">[M,N]=size(image); % get the image size</span><br><span class="line">T=zeros(M,N);</span><br><span class="line">tic % start counting</span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span>:M % <span class="keyword">for</span> every row</span><br><span class="line">    <span class="keyword">for</span> y = <span class="number">1</span>:N % <span class="keyword">for</span> every column</span><br><span class="line">        <span class="keyword">for</span> u =<span class="number">1</span>:M</span><br><span class="line">            <span class="keyword">for</span> v = <span class="number">1</span>:N</span><br><span class="line">                E = <span class="built_in">exp</span>(<span class="number">-1</span>i*<span class="number">2</span>*pi*(((u<span class="number">-1</span>)*(x<span class="number">-1</span>)/M)+((v<span class="number">-1</span>)*(y<span class="number">-1</span>)/N))); % get <span class="built_in">exp</span> kernel</span><br><span class="line">                <span class="title function_">T</span><span class="params">(x,y)</span> = T(x,y) + image(u,v)*E;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">toc % stop counting</span><br><span class="line"><span class="title function_">subplot</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span>,<span class="title function_">imshow</span><span class="params">(raw_image)</span>,<span class="title function_">title</span><span class="params">(<span class="string">&#x27;raw&#x27;</span>)</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(T),title(<span class="string">&#x27;2D-DFT&#x27;</span>);</span><br></pre></td></tr></table></figure><br>用我最喜欢的憨憨龟来测试</p><p><img src="https://img-blog.csdnimg.cn/20200302110900321.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NjAwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>用时1081.484753 秒，可以说是最憨的一种实现方式了。<br>另一篇文章介绍了<a href="/2020/03/01/%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4DFT%E5%8F%A0%E5%8A%A0%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%9B%BE%E7%89%87%E4%BA%8C%E7%BB%B4%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/" title="一维的DFT叠加方式">一维的DFT叠加方式</a></p>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用一维DFT叠加实现对图片二维傅立叶变换</title>
      <link href="/2020/03/01/%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4DFT%E5%8F%A0%E5%8A%A0%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%9B%BE%E7%89%87%E4%BA%8C%E7%BB%B4%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/2020/03/01/%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BB%B4DFT%E5%8F%A0%E5%8A%A0%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%9B%BE%E7%89%87%E4%BA%8C%E7%BB%B4%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>使用两次一维DFT的叠加方式实现二维的DFT运算可以有效的减少计算成本。</p><p>一维DFT公式</p><script type="math/tex; mode=display">X[k]=\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn}</script><h3 id="将DFT转化为矩阵运算"><a href="#将DFT转化为矩阵运算" class="headerlink" title="将DFT转化为矩阵运算"></a>将DFT转化为矩阵运算</h3><p>在MATLAB中，使用矩阵运算比循环更加有效率。下面展示对每一行的处理：（以256x256大小图片举例）<br>对第i行进行DFT处理，则第i行第一个元素的卷积为：<br>$x[i,1]e^{-j\frac{2\pi}{N}0<em>0}+x[i,1]e^{-j\frac{2\pi}{N}0</em>1}+…+x[i,1]e^{-j\frac{2\pi}{N}0*255}$<br>所以将每行的每个元素都进行此运算之后得到：</p><script type="math/tex; mode=display">X[i，1]=x[i,1]e^{-j\frac{2\pi}{N}0*0}+x[i,1]e^{-j\frac{2\pi}{N}0*1}+...+x[i,1]e^{-j\frac{2\pi}{N}0*255}\\X[i，2]=x[i,2]e^{-j\frac{2\pi}{N}1*0}+x[i,2]e^{-j\frac{2\pi}{N}1*1}+...+x[i,2]e^{-j\frac{2\pi}{N}1*2}\\...\\...\\X[i，256]=x[i,256]e^{-j\frac{2\pi}{N}255*0}+x[i,256]e^{-j\frac{2\pi}{N}255*1}+...+x[i,256]e^{-j\frac{2\pi}{N}255*255}</script><p>所以对于图像每一行组成的行向量，指数部分就是：<br>第1个元素：$0<em>0+0</em>1+…+0<em>255$<br>第256个元素：$255</em>0+255<em>1+…+255</em>255$<br>这种加法刚好就构成了一个向量和一个矩阵的乘法过程。</p><p>我们构建一个由0到255的列向量和0到255的行向量相乘得到的255x255大小的矩阵。姑且叫做EMatrix。</p><script type="math/tex; mode=display">e^{-j\frac{2\pi}{N}}\begin{bmatrix}0\\ ...\\ 255\end{bmatrix}*\begin{bmatrix}0 & ... & 255\end{bmatrix}=e^{-j\frac{2\pi}{N}}\begin{bmatrix} 0*0& 0*1 & ... &0*255\\  ...&  ...&  ...& ...\\  ...&  ...&  ...& ...\\  255*0&  ...&  ...&255*255 \end{bmatrix}</script><p>所以对于图片的每一行，第一个元素会对应乘上矩阵的第一行的每个元素并相加，得到对应的第一元素的X[k]，将每一行都乘以这个矩阵就可以得到对图片进行行处理的结果。</p><script type="math/tex; mode=display">X[i,:]=x[i,:]*EMatrix=\begin{bmatrix}x[i,1] & ... & ... & x[i,256]\end{bmatrix}*e^{-j\frac{2\pi}{N}}\begin{bmatrix} 0*0& 0*1 & ... &0*255\\  ...&  ...&  ...& ...\\  ...&  ...&  ...& ...\\  255*0&  ...&  ...&255*255 \end{bmatrix}</script><p>下一步就是对图片的每一列进行相同的步骤，不过注意列向量拿出来之后需要转置再乘EMatrix再转置得到对应列的结果。</p><h2 id="MATLAB代码"><a href="#MATLAB代码" class="headerlink" title="MATLAB代码"></a>MATLAB代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%% Q2 <span class="number">1</span>D-DFT</span><br><span class="line">raw_image=imread(<span class="string">&#x27;hh.jpg&#x27;</span>); % read image</span><br><span class="line">image=im2double(rgb2gray(raw_image));</span><br><span class="line">[M,N]=size(image);</span><br><span class="line">one_d1=zeros(M,N); % x-dimention</span><br><span class="line">one_d2=zeros(M,N);% y-dimention</span><br><span class="line">k=<span class="number">0</span>:<span class="number">1</span>:<span class="number">255</span>; </span><br><span class="line">n=<span class="number">0</span>:<span class="number">1</span>:<span class="number">255</span>;</span><br><span class="line">kn=k<span class="number">&#x27;</span>*n; % get <span class="built_in">exp</span> kernel</span><br><span class="line">E=<span class="built_in">exp</span>(<span class="number">-1</span>i*<span class="number">2</span>*pi/<span class="number">256</span>).^(kn);</span><br><span class="line">tic % start counting</span><br><span class="line"><span class="keyword">for</span> a=<span class="number">1</span>:M % <span class="keyword">for</span> every row</span><br><span class="line">    one_d1(a,:)=image(a,:)*E;</span><br><span class="line">end</span><br><span class="line"><span class="keyword">for</span> b=<span class="number">1</span>:N % <span class="keyword">for</span> every column</span><br><span class="line">    one_d2(:,b)=(one_d1(:,b)<span class="string">&#x27;*E)&#x27;</span>;</span><br><span class="line">end</span><br><span class="line">toc % stop counting</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(raw_image),title(<span class="string">&#x27;raw&#x27;</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(one_d2),title(<span class="string">&#x27;1D-DFT&#x27;</span>);</span><br></pre></td></tr></table></figure><p>用我最喜欢的憨憨龟来测试一下</p><p><img src="https://img-blog.csdnimg.cn/20200227081919736.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NjAwOA==,size_16,color_FFFFFF,t_70" alt="憨憨"></p><p>用时0.014302秒，相比于直接用公式计算2D的DFT要快非常多。</p><p>提到傅里叶变换就不得不提到<a href="/2020/10/12/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2FFT/" title="快速傅立叶变换FFT">快速傅立叶变换FFT</a></p>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
